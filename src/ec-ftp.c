#include <arpa/inet.h>
#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#include "comp.h"
#include "enc.h"
#include "ec-ftp.h"


/** Takes a string and modifies it such that there is no leading or trailing
 * whitespace.
 *
 * \param '*str' the input string which will be modified.
 * \return void.
 */
void trim(char *str) {
	int i;
	int len = strlen(str);
	int begin = 0;
	int end = len - 1;

	/* Find index of first non-whitespace character */
	while ((begin < len) && isspace((unsigned char) str[begin]))
		begin++;

	/* Find index of last non-whitespace character */
	while ((end >= begin) && isspace((unsigned char) str[end]))
		end--;

	/* Shift all characters caught between leading and trailing whitespace
	 * to the start of the string */
	for (i = begin; i <= end; i++)
		str[i - begin] = str[i];

	/* Note: if the string contained nothing but whitespace, a string of 0
	 * length is returned */
	str[i - begin] = '\0';
}


/* Modifies 'port' to contain the port of the socket represented by 'fd'.
 *
 * \param 'fd' a file descriptor representing a socket.
 * \param '*port' a pointer to a short which will have its value modified to
 *     the port of the socket.
 * \return 0 upon success, a negative int upon failure.
 */
int get_port(int fd, uint16_t *port){
	struct sockaddr_in s;
	socklen_t len = sizeof(s);

	if (getsockname(fd, (struct sockaddr *)&s, &len) == -1) {
		return -1;
	} else {
		(*port) = ntohs(s.sin_port);
		return 0;
	}
}


// TODO: what does this function do? My best guess at the moment is that it
// modifies 'ip', and 'port' to contain the IP address and port of the socket
// represented by 'fd'
int get_ip_port(int fd, char *ip, uint16_t *port){
	struct sockaddr_in addr;
	socklen_t len = sizeof(addr);

	getsockname(fd, (struct sockaddr *) &addr, &len);
	// TODO: potential security risk. Switch to strncpy?
	sprintf(ip, inet_ntoa(addr.sin_addr));
	*port = (uint16_t) ntohs(addr.sin_port);
	return 1;
}


/** Takes a string 'filename' representing a file path and returns a string
 * that is the given file path + the compression extension, the encryption
 * extension and a series of temp file digits. The caller of this function must
 * free the returned string.
 *
 * \param '*filename' a string representing a filepath where the decrypted and
 *     decompressed file will be written.
 * \return a temp file for receiving a file upon success, a NULL pointer on
 *     failure.
 */
char * temp_recv_name(char * filename) {
	char * c_out_fp_pure;
	char * recv_fp;
	/* Get the "pure" name for the compressed version of the file, i.e., the
	 * temp compression file name minus the 'mkstemp()' digits (
	 * '<filename>.comp' ) */
	if ( (c_out_fp_pure = compression_name(filename)) == NULL) {
		fprintf(stderr, "ERROR: failed to receive file!\n");
		return NULL;
	}

	/* Take the "pure" compressed name and get a temp encryption name for it
	 * ( '<filename>.comp.enc-XXXXXX' ) */
	if ( (recv_fp = temp_encryption_name(c_out_fp_pure)) == NULL) {
		fprintf(stderr, "ERROR: failed to receive file!\n");
		return NULL;
	}

	free(c_out_fp_pure);

	return recv_fp;
}


/** Takes a string 'filename' representing an input file path, a key used to
 * encrypt the file, and pointer to a pointer serving as a return variable, and
 * encrypts and compresses the file, storing the result at
 * '*(ret_prepared_fp)'. The caller of this function must free
 * '*(ret_prepared_fp)'.
 *
 * \param '*filename' a string representing a filepath to the file to be
 *     compressed and encrypted.
 * \param 'key' a key used for the decryption part of this process.
 * \param '**ret_prepared_fp' a pointer which will be modified to contain
 *     a pointer to the filename of the temporary prepared file generated by
 *     this function.
 * \return 0 upon success, a negative int upon failure.
 */
int prepare_file(char * filename, uint32_t key[4], char ** ret_prepared_fp) {
	char * c_out_fp;
	char * c_out_fp_pure;
	char * e_out_fp;

	/* Get temp name for compressed version of the file */
	if ( (c_out_fp = temp_compression_name(filename)) == NULL) {
		fprintf(stderr, "ERROR: could not compress file!\n");
		return -1;
	}

	/* Compress content of file at 'filename' writing output to file at
	 * 'c_out_fp' */
	if (0 != comp_file(filename, c_out_fp)) {
		fprintf(stderr, "ERROR: could not compress file!\n");
		return -1;
	}

	/* Get the "pure" name for the compressed version of the file, i.e.,
	 * the temp compression file name minus the 'mkstemp()' digits */
	if ( (c_out_fp_pure = compression_name(filename)) == NULL) {
		fprintf(stderr, "ERROR: could not encrypt file!\n");
		return -1;
	}
	/* CAE3b: Get temp name for encrypted version of the compressed file */
	if ( (e_out_fp = temp_encryption_name(c_out_fp_pure)) == NULL) {
		fprintf(stderr, "ERROR: could not encrypt file!\n");
		return -1;
	}

	free(c_out_fp_pure);

	/* Encrypt content of file at 'filename' writing output to file at
	 * 'e_out_fp' */
	if (0 != enc_file(c_out_fp, e_out_fp, key)) {
		fprintf(stderr, "ERROR: could not encrypt file!\n");
		return -1;
	}

	if (KEEP_TEMP_COMP_FILES != 1) {
		if (0 != remove(c_out_fp)) {
			fprintf(stderr, "WARNING: could not remove temporary compressed .comp file!\n");
		} 
	}

	free(c_out_fp);

	(*ret_prepared_fp) = e_out_fp;

	return 0;
}


/** Takes a string 'filename' representing an output file path, a string
 * representing a path to a received file 'recv_fp', and a key used to decrypt
 * the file and decrypts and decompresses the file, storing the result at
 * 'filename'.
 *
 * \param '*filename' a string representing a filepath where the decrypted and
 *     decompressed file will be written.
 * \param '*recv_fp' a string representing a filepath to a received file which
 *     will be compressed and encrypted.
 * \param 'key' a key used for the decryption part of this process.
 * \return 0 upon success, a negative int upon failure.
 */
int process_received_file(char * filename, char * recv_fp, uint32_t key[4]) {
	char * dec_out_fp;
	/* Make temporary name for decryted (but not yet decompressed) file
	 * ( '<filename>.comp-XXXXXX' ) */
	if ( (dec_out_fp = temp_compression_name(filename)) == NULL) {
		fprintf(stderr, "ERROR: could not decrypt file!\n");
		return -1;
	}

	/* Decrypt content of file at 'recv_fp' writing output to file at
	 * 'dec_out_fp' */
	if (0 != dec_file(recv_fp, dec_out_fp, key)) {
		fprintf(stderr, "ERROR: could not decrypt file!\n");
		return -1;
	}

	if (KEEP_TEMP_ENC_FILES != 1) {
		if (0 != remove(recv_fp)) {
			fprintf(stderr, "WARNING: could not remove temporary encrypted .enc file!\n");
		}
	}

	/* Uncompress content of file at 'dec_out_fp' writing output to file at
	 * 'filename' */
	if (0 != uncomp_file(dec_out_fp, filename)) {
		fprintf(stderr, "ERROR: could not uncompress file!\n");
		return -1;
	}

	if (KEEP_TEMP_COMP_FILES != 1) {
		if (0 != remove(dec_out_fp)) {
			fprintf(stderr, "WARNING: could not remove temporary compressed .comp file!\n");
		}
	}

	free(dec_out_fp);

	return 0;
}


/* CSCD58 Addition - Encryption */
int do_dh_client(int controlfd, int datafd, uint32_t key[4]) {
	uint64_t dh_p = 1;
	dh_p = (dh_p << 32) - 99;
	uint64_t dh_g = 5;
	uint64_t dh_a, dh_ka, dh_kb, dh_k;
	fd_set readfds;
	FD_ZERO(&readfds);

	for (int i = 0; i < 4; i++) {
		dh_a = (rand() % (dh_p - 2)) + 2;
		dh_ka = sq_mp(dh_g, dh_a, dh_p);
		FD_SET(datafd, &readfds);

		write(datafd, (char *)&dh_ka, sizeof(dh_ka));

		select(datafd + 1, &readfds, NULL, NULL, NULL);
		read(datafd, (char *)&dh_kb, sizeof(dh_kb));

		dh_k = sq_mp(dh_kb, dh_a, dh_p);
		key[i] = dh_k & 0xffffffff;
	}

	return 0;
}
/* End CSCD58 Addition - Encryption */


/* CSCD58 addition - Encryption + Parallelization? */
int do_dh_server(int controlfd, int datafd, uint32_t key[4]) {
	uint64_t dh_p = 1;
	dh_p = (dh_p << 32) - 99;
	uint64_t dh_g = 5;
	uint64_t dh_b, dh_ka, dh_kb, dh_k;
	// TODO: are readfds ever used properly in this function? we call select on
	// them, but no fd other than datafd is ever accessed and I don't think we
	// do anything with the fd_set readfds (i.e. we never check if any of the
	// fds in the set are set and never do anything particular to a given fd in
	// the set)
	fd_set readfds;
	FD_ZERO(&readfds);

	for (int i = 0; i < 4; i++) {
		dh_b = (rand() % (dh_p - 2)) + 2;
		dh_kb = sq_mp(dh_g, dh_b, dh_p);
		FD_SET(datafd, &readfds);

		select(datafd + 1, &readfds, NULL, NULL, NULL);
		read(datafd, (char *)&dh_ka, sizeof(dh_ka));

		write(datafd, (char *)&dh_kb, sizeof(dh_kb));

		dh_k = sq_mp(dh_ka, dh_b, dh_p);
		key[i] = dh_k & 0xffffffff;
	}
	
	return 0;
}
/* CSCD58 end of addition - Encryption + Parallelization? */


void close_data_connections(int *datafds) {
	for (int i = 0; i < NDATAFD; i++) {
		close(datafds[i]);
	}
}
